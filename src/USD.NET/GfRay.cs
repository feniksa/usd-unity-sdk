//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (http://www.swig.org).
// Version 3.0.12
//
// Do not make changes to this file unless you know what you are doing--modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace pxr {

public class GfRay : global::System.IDisposable {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal GfRay(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(GfRay obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  ~GfRay() {
    Dispose();
  }

  public virtual void Dispose() {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          USDIPCPINVOKE.delete_GfRay(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
      global::System.GC.SuppressFinalize(this);
    }
  }

  public GfRay() : this(USDIPCPINVOKE.new_GfRay__SWIG_0(), true) {
  }

  public GfRay(GfVec3d startPoint, GfVec3d direction) : this(USDIPCPINVOKE.new_GfRay__SWIG_1(GfVec3d.getCPtr(startPoint), GfVec3d.getCPtr(direction)), true) {
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
  }

  public void SetPointAndDirection(GfVec3d startPoint, GfVec3d direction) {
    USDIPCPINVOKE.GfRay_SetPointAndDirection(swigCPtr, GfVec3d.getCPtr(startPoint), GfVec3d.getCPtr(direction));
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
  }

  public void SetEnds(GfVec3d startPoint, GfVec3d endPoint) {
    USDIPCPINVOKE.GfRay_SetEnds(swigCPtr, GfVec3d.getCPtr(startPoint), GfVec3d.getCPtr(endPoint));
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
  }

  public GfVec3d GetStartPoint() {
    GfVec3d ret = new GfVec3d(USDIPCPINVOKE.GfRay_GetStartPoint(swigCPtr), false);
    return ret;
  }

  public GfVec3d GetDirection() {
    GfVec3d ret = new GfVec3d(USDIPCPINVOKE.GfRay_GetDirection(swigCPtr), false);
    return ret;
  }

  public GfVec3d GetPoint(double distance) {
    GfVec3d ret = new GfVec3d(USDIPCPINVOKE.GfRay_GetPoint(swigCPtr, distance), true);
    return ret;
  }

  public GfRay Transform(GfMatrix4d matrix) {
    GfRay ret = new GfRay(USDIPCPINVOKE.GfRay_Transform(swigCPtr, GfMatrix4d.getCPtr(matrix)), false);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public GfVec3d FindClosestPoint(GfVec3d point, out double rayDistance) {
    GfVec3d ret = new GfVec3d(USDIPCPINVOKE.GfRay_FindClosestPoint__SWIG_0(swigCPtr, GfVec3d.getCPtr(point), out rayDistance), true);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public GfVec3d FindClosestPoint(GfVec3d point) {
    GfVec3d ret = new GfVec3d(USDIPCPINVOKE.GfRay_FindClosestPoint__SWIG_1(swigCPtr, GfVec3d.getCPtr(point)), true);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfVec3d p0, GfVec3d p1, GfVec3d p2, out double distance, GfVec3d barycentricCoords, out bool frontFacing, double maxDist) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_0(swigCPtr, GfVec3d.getCPtr(p0), GfVec3d.getCPtr(p1), GfVec3d.getCPtr(p2), out distance, GfVec3d.getCPtr(barycentricCoords), out frontFacing, maxDist);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfVec3d p0, GfVec3d p1, GfVec3d p2, out double distance, GfVec3d barycentricCoords, out bool frontFacing) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_1(swigCPtr, GfVec3d.getCPtr(p0), GfVec3d.getCPtr(p1), GfVec3d.getCPtr(p2), out distance, GfVec3d.getCPtr(barycentricCoords), out frontFacing);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfVec3d p0, GfVec3d p1, GfVec3d p2, out double distance, GfVec3d barycentricCoords) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_2(swigCPtr, GfVec3d.getCPtr(p0), GfVec3d.getCPtr(p1), GfVec3d.getCPtr(p2), out distance, GfVec3d.getCPtr(barycentricCoords));
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfVec3d p0, GfVec3d p1, GfVec3d p2, out double distance) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_3(swigCPtr, GfVec3d.getCPtr(p0), GfVec3d.getCPtr(p1), GfVec3d.getCPtr(p2), out distance);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfVec3d p0, GfVec3d p1, GfVec3d p2) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_4(swigCPtr, GfVec3d.getCPtr(p0), GfVec3d.getCPtr(p1), GfVec3d.getCPtr(p2));
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfPlane plane, out double distance, out bool frontFacing) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_5(swigCPtr, GfPlane.getCPtr(plane), out distance, out frontFacing);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfPlane plane, out double distance) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_6(swigCPtr, GfPlane.getCPtr(plane), out distance);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfPlane plane) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_7(swigCPtr, GfPlane.getCPtr(plane));
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfRange3d box, out double enterDistance, out double exitDistance) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_8(swigCPtr, GfRange3d.getCPtr(box), out enterDistance, out exitDistance);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfRange3d box, out double enterDistance) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_9(swigCPtr, GfRange3d.getCPtr(box), out enterDistance);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfRange3d box) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_10(swigCPtr, GfRange3d.getCPtr(box));
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfVec3d center, double radius, out double enterDistance, out double exitDistance) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_11(swigCPtr, GfVec3d.getCPtr(center), radius, out enterDistance, out exitDistance);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfVec3d center, double radius, out double enterDistance) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_12(swigCPtr, GfVec3d.getCPtr(center), radius, out enterDistance);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfVec3d center, double radius) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_13(swigCPtr, GfVec3d.getCPtr(center), radius);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfVec3d origin, GfVec3d axis, double radius, out double enterDistance, out double exitDistance) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_14(swigCPtr, GfVec3d.getCPtr(origin), GfVec3d.getCPtr(axis), radius, out enterDistance, out exitDistance);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfVec3d origin, GfVec3d axis, double radius, out double enterDistance) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_15(swigCPtr, GfVec3d.getCPtr(origin), GfVec3d.getCPtr(axis), radius, out enterDistance);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfVec3d origin, GfVec3d axis, double radius) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_16(swigCPtr, GfVec3d.getCPtr(origin), GfVec3d.getCPtr(axis), radius);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfVec3d origin, GfVec3d axis, double radius, double height, out double enterDistance, out double exitDistance) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_17(swigCPtr, GfVec3d.getCPtr(origin), GfVec3d.getCPtr(axis), radius, height, out enterDistance, out exitDistance);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfVec3d origin, GfVec3d axis, double radius, double height, out double enterDistance) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_18(swigCPtr, GfVec3d.getCPtr(origin), GfVec3d.getCPtr(axis), radius, height, out enterDistance);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public bool Intersect(GfVec3d origin, GfVec3d axis, double radius, double height) {
    bool ret = USDIPCPINVOKE.GfRay_Intersect__SWIG_19(swigCPtr, GfVec3d.getCPtr(origin), GfVec3d.getCPtr(axis), radius, height);
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public static bool Equals(GfRay lhs, GfRay rhs) {
    bool ret = USDIPCPINVOKE.GfRay_Equals(GfRay.getCPtr(lhs), GfRay.getCPtr(rhs));
    if (USDIPCPINVOKE.SWIGPendingException.Pending) throw USDIPCPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  override public int GetHashCode() {
    int ret = USDIPCPINVOKE.GfRay_GetHashCode(swigCPtr);
    return ret;
  }

    public static bool operator==(GfRay lhs, GfRay rhs){
      // The Swig binding glue will re-enter this operator comparing to null, so 
      // that case must be handled explicitly to avoid an infinite loop. This is still
      // not great, since it crosses the C#/C++ barrier twice. A better approache might
      // be to return a simple value from C++ that can be compared in C#.
      bool lnull = lhs as object == null;
      bool rnull = rhs as object == null;
      return (lnull == rnull) && ((lnull && rnull) || GfRay.Equals(lhs, rhs));
    }

    public static bool operator !=(GfRay lhs, GfRay rhs) {
        return !(lhs == rhs);
    }

    override public bool Equals(object rhs) {
      return GfRay.Equals(this, rhs as GfRay);
    }
  
}

}
